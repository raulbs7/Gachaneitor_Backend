# Generated from Gachaneitor.g4 by ANTLR 4.9
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3#")
        buf.write("\u0086\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\3\2\3\2")
        buf.write("\7\2\'\n\2\f\2\16\2*\13\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\4\5\4\66\n\4\3\4\3\4\3\4\3\4\3\5\5\5=\n\5\3")
        buf.write("\5\3\5\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\b\3\b\3\b\6\bQ\n\b\r\b\16\bR\3\t\3\t\3\t\3\t\3")
        buf.write("\t\3\t\3\n\3\n\3\n\6\n^\n\n\r\n\16\n_\3\n\3\n\3\13\3\13")
        buf.write("\3\13\5\13g\n\13\3\f\3\f\3\f\3\f\3\f\3\f\3\r\3\r\3\r\3")
        buf.write("\r\3\r\3\r\3\16\3\16\3\16\3\16\3\17\3\17\3\17\3\20\3\20")
        buf.write("\3\20\3\21\3\21\3\21\3\21\3\22\3\22\3\22\3\22\2\2\23\2")
        buf.write("\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"\2\2\2{\2$\3\2")
        buf.write("\2\2\4+\3\2\2\2\6\65\3\2\2\2\b<\3\2\2\2\n@\3\2\2\2\fH")
        buf.write("\3\2\2\2\16P\3\2\2\2\20T\3\2\2\2\22Z\3\2\2\2\24f\3\2\2")
        buf.write("\2\26h\3\2\2\2\30n\3\2\2\2\32t\3\2\2\2\34x\3\2\2\2\36")
        buf.write("{\3\2\2\2 ~\3\2\2\2\"\u0082\3\2\2\2$(\5\4\3\2%\'\5\4\3")
        buf.write("\2&%\3\2\2\2\'*\3\2\2\2(&\3\2\2\2()\3\2\2\2)\3\3\2\2\2")
        buf.write("*(\3\2\2\2+,\7\3\2\2,-\7\27\2\2-.\5\6\4\2./\5\b\5\2/\60")
        buf.write("\5\n\6\2\60\61\5\f\7\2\61\62\5\22\n\2\62\63\7\30\2\2\63")
        buf.write("\5\3\2\2\2\64\66\7\4\2\2\65\64\3\2\2\2\65\66\3\2\2\2\66")
        buf.write("\67\3\2\2\2\678\7\31\2\289\7\34\2\29:\7\31\2\2:\7\3\2")
        buf.write("\2\2;=\7\5\2\2<;\3\2\2\2<=\3\2\2\2=>\3\2\2\2>?\7\37\2")
        buf.write("\2?\t\3\2\2\2@A\7\6\2\2AB\7\27\2\2BC\7\7\2\2CD\5\36\20")
        buf.write("\2DE\7\b\2\2EF\5\36\20\2FG\7\30\2\2G\13\3\2\2\2HI\7\r")
        buf.write("\2\2IJ\7\27\2\2JK\5\16\b\2KL\7\30\2\2L\r\3\2\2\2MN\5\20")
        buf.write("\t\2NO\7\n\2\2OQ\3\2\2\2PM\3\2\2\2QR\3\2\2\2RP\3\2\2\2")
        buf.write("RS\3\2\2\2S\17\3\2\2\2TU\7\31\2\2UV\7\34\2\2VW\7\31\2")
        buf.write("\2WX\7\t\2\2XY\5\34\17\2Y\21\3\2\2\2Z[\7\f\2\2[]\7\27")
        buf.write("\2\2\\^\5\24\13\2]\\\3\2\2\2^_\3\2\2\2_]\3\2\2\2_`\3\2")
        buf.write("\2\2`a\3\2\2\2ab\7\30\2\2b\23\3\2\2\2cg\5\26\f\2dg\5\30")
        buf.write("\r\2eg\5\32\16\2fc\3\2\2\2fd\3\2\2\2fe\3\2\2\2g\25\3\2")
        buf.write("\2\2hi\7\13\2\2ij\7\23\2\2jk\5\16\b\2kl\5\36\20\2lm\5")
        buf.write("\"\22\2m\27\3\2\2\2no\7\13\2\2op\7\24\2\2pq\5\16\b\2q")
        buf.write("r\5\36\20\2rs\5 \21\2s\31\3\2\2\2tu\7\13\2\2uv\7\25\2")
        buf.write("\2vw\5\16\b\2w\33\3\2\2\2xy\7\32\2\2yz\7\20\2\2z\35\3")
        buf.write("\2\2\2{|\7\32\2\2|}\7\22\2\2}\37\3\2\2\2~\177\7\16\2\2")
        buf.write("\177\u0080\7\32\2\2\u0080\u0081\7\21\2\2\u0081!\3\2\2")
        buf.write("\2\u0082\u0083\7\17\2\2\u0083\u0084\7\33\2\2\u0084#\3")
        buf.write("\2\2\2\b(\65<R_f")
        return buf.getvalue()


class GachaneitorParser ( Parser ):

    grammarFileName = "Gachaneitor.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'receta'", "'nombre'", "'descripcion'", 
                     "'tiempo'", "'total'", "'preparacion'", "':'", "';'", 
                     "'-'", "'pasos'", "'ingredientes'", "'temperatura'", 
                     "'velocidad'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'{'", "'}'", "'\"'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'['", "']'" ]

    symbolicNames = [ "<INVALID>", "RECETA", "NOMBRE", "DESCRIPCION", "TIEMPO", 
                      "TOTAL", "PREPARACION", "DOSPUNTOS", "PUNTOYCOMA", 
                      "GUION", "PASOS", "INGREDIENTES", "TEMPERATURA", "VELOCIDAD", 
                      "UNIDAD_CANTIDAD", "UNIDAD_TEMP", "UNIDAD_TIEMPO", 
                      "VERBO_MOV", "VERBO_COC", "VERBO_PER", "OTROS_CARACTERES", 
                      "LLAVE_ABIERTA", "LLAVE_CERRADA", "COMILLA", "NUMERO", 
                      "DIGITO_VELOCIDAD", "IDENT_NOMBRE", "CADENA", "TILDES", 
                      "CONTENIDO_DESCRIPCION", "CORCHETE_ABIERTO", "CORCHETE_CERRADO", 
                      "COMMENT", "WS" ]

    RULE_inicio = 0
    RULE_receta = 1
    RULE_nombre = 2
    RULE_descripcion = 3
    RULE_tiempo_receta = 4
    RULE_ingredientes = 5
    RULE_ingrediente_lista = 6
    RULE_ingrediente = 7
    RULE_pasos = 8
    RULE_paso = 9
    RULE_paso_mov = 10
    RULE_paso_coc = 11
    RULE_paso_per = 12
    RULE_cantidad = 13
    RULE_tiempo = 14
    RULE_temperatura = 15
    RULE_velocidad = 16

    ruleNames =  [ "inicio", "receta", "nombre", "descripcion", "tiempo_receta", 
                   "ingredientes", "ingrediente_lista", "ingrediente", "pasos", 
                   "paso", "paso_mov", "paso_coc", "paso_per", "cantidad", 
                   "tiempo", "temperatura", "velocidad" ]

    EOF = Token.EOF
    RECETA=1
    NOMBRE=2
    DESCRIPCION=3
    TIEMPO=4
    TOTAL=5
    PREPARACION=6
    DOSPUNTOS=7
    PUNTOYCOMA=8
    GUION=9
    PASOS=10
    INGREDIENTES=11
    TEMPERATURA=12
    VELOCIDAD=13
    UNIDAD_CANTIDAD=14
    UNIDAD_TEMP=15
    UNIDAD_TIEMPO=16
    VERBO_MOV=17
    VERBO_COC=18
    VERBO_PER=19
    OTROS_CARACTERES=20
    LLAVE_ABIERTA=21
    LLAVE_CERRADA=22
    COMILLA=23
    NUMERO=24
    DIGITO_VELOCIDAD=25
    IDENT_NOMBRE=26
    CADENA=27
    TILDES=28
    CONTENIDO_DESCRIPCION=29
    CORCHETE_ABIERTO=30
    CORCHETE_CERRADO=31
    COMMENT=32
    WS=33

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class InicioContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def receta(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GachaneitorParser.RecetaContext)
            else:
                return self.getTypedRuleContext(GachaneitorParser.RecetaContext,i)


        def getRuleIndex(self):
            return GachaneitorParser.RULE_inicio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInicio" ):
                listener.enterInicio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInicio" ):
                listener.exitInicio(self)




    def inicio(self):

        localctx = GachaneitorParser.InicioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_inicio)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 34
            self.receta()
            self.state = 38
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GachaneitorParser.RECETA:
                self.state = 35
                self.receta()
                self.state = 40
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RecetaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RECETA(self):
            return self.getToken(GachaneitorParser.RECETA, 0)

        def LLAVE_ABIERTA(self):
            return self.getToken(GachaneitorParser.LLAVE_ABIERTA, 0)

        def nombre(self):
            return self.getTypedRuleContext(GachaneitorParser.NombreContext,0)


        def descripcion(self):
            return self.getTypedRuleContext(GachaneitorParser.DescripcionContext,0)


        def tiempo_receta(self):
            return self.getTypedRuleContext(GachaneitorParser.Tiempo_recetaContext,0)


        def ingredientes(self):
            return self.getTypedRuleContext(GachaneitorParser.IngredientesContext,0)


        def pasos(self):
            return self.getTypedRuleContext(GachaneitorParser.PasosContext,0)


        def LLAVE_CERRADA(self):
            return self.getToken(GachaneitorParser.LLAVE_CERRADA, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_receta

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReceta" ):
                listener.enterReceta(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReceta" ):
                listener.exitReceta(self)




    def receta(self):

        localctx = GachaneitorParser.RecetaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_receta)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 41
            self.match(GachaneitorParser.RECETA)
            self.state = 42
            self.match(GachaneitorParser.LLAVE_ABIERTA)
            self.state = 43
            self.nombre()
            self.state = 44
            self.descripcion()
            self.state = 45
            self.tiempo_receta()
            self.state = 46
            self.ingredientes()
            self.state = 47
            self.pasos()
            self.state = 48
            self.match(GachaneitorParser.LLAVE_CERRADA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NombreContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMILLA(self, i:int=None):
            if i is None:
                return self.getTokens(GachaneitorParser.COMILLA)
            else:
                return self.getToken(GachaneitorParser.COMILLA, i)

        def IDENT_NOMBRE(self):
            return self.getToken(GachaneitorParser.IDENT_NOMBRE, 0)

        def NOMBRE(self):
            return self.getToken(GachaneitorParser.NOMBRE, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_nombre

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNombre" ):
                listener.enterNombre(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNombre" ):
                listener.exitNombre(self)




    def nombre(self):

        localctx = GachaneitorParser.NombreContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_nombre)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 51
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GachaneitorParser.NOMBRE:
                self.state = 50
                self.match(GachaneitorParser.NOMBRE)


            self.state = 53
            self.match(GachaneitorParser.COMILLA)
            self.state = 54
            self.match(GachaneitorParser.IDENT_NOMBRE)
            self.state = 55
            self.match(GachaneitorParser.COMILLA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DescripcionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONTENIDO_DESCRIPCION(self):
            return self.getToken(GachaneitorParser.CONTENIDO_DESCRIPCION, 0)

        def DESCRIPCION(self):
            return self.getToken(GachaneitorParser.DESCRIPCION, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_descripcion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDescripcion" ):
                listener.enterDescripcion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDescripcion" ):
                listener.exitDescripcion(self)




    def descripcion(self):

        localctx = GachaneitorParser.DescripcionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_descripcion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 58
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GachaneitorParser.DESCRIPCION:
                self.state = 57
                self.match(GachaneitorParser.DESCRIPCION)


            self.state = 60
            self.match(GachaneitorParser.CONTENIDO_DESCRIPCION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tiempo_recetaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIEMPO(self):
            return self.getToken(GachaneitorParser.TIEMPO, 0)

        def LLAVE_ABIERTA(self):
            return self.getToken(GachaneitorParser.LLAVE_ABIERTA, 0)

        def TOTAL(self):
            return self.getToken(GachaneitorParser.TOTAL, 0)

        def tiempo(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GachaneitorParser.TiempoContext)
            else:
                return self.getTypedRuleContext(GachaneitorParser.TiempoContext,i)


        def PREPARACION(self):
            return self.getToken(GachaneitorParser.PREPARACION, 0)

        def LLAVE_CERRADA(self):
            return self.getToken(GachaneitorParser.LLAVE_CERRADA, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_tiempo_receta

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTiempo_receta" ):
                listener.enterTiempo_receta(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTiempo_receta" ):
                listener.exitTiempo_receta(self)




    def tiempo_receta(self):

        localctx = GachaneitorParser.Tiempo_recetaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_tiempo_receta)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 62
            self.match(GachaneitorParser.TIEMPO)
            self.state = 63
            self.match(GachaneitorParser.LLAVE_ABIERTA)
            self.state = 64
            self.match(GachaneitorParser.TOTAL)
            self.state = 65
            self.tiempo()
            self.state = 66
            self.match(GachaneitorParser.PREPARACION)
            self.state = 67
            self.tiempo()
            self.state = 68
            self.match(GachaneitorParser.LLAVE_CERRADA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IngredientesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INGREDIENTES(self):
            return self.getToken(GachaneitorParser.INGREDIENTES, 0)

        def LLAVE_ABIERTA(self):
            return self.getToken(GachaneitorParser.LLAVE_ABIERTA, 0)

        def ingrediente_lista(self):
            return self.getTypedRuleContext(GachaneitorParser.Ingrediente_listaContext,0)


        def LLAVE_CERRADA(self):
            return self.getToken(GachaneitorParser.LLAVE_CERRADA, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_ingredientes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIngredientes" ):
                listener.enterIngredientes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIngredientes" ):
                listener.exitIngredientes(self)




    def ingredientes(self):

        localctx = GachaneitorParser.IngredientesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_ingredientes)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 70
            self.match(GachaneitorParser.INGREDIENTES)
            self.state = 71
            self.match(GachaneitorParser.LLAVE_ABIERTA)
            self.state = 72
            self.ingrediente_lista()
            self.state = 73
            self.match(GachaneitorParser.LLAVE_CERRADA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ingrediente_listaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ingrediente(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GachaneitorParser.IngredienteContext)
            else:
                return self.getTypedRuleContext(GachaneitorParser.IngredienteContext,i)


        def PUNTOYCOMA(self, i:int=None):
            if i is None:
                return self.getTokens(GachaneitorParser.PUNTOYCOMA)
            else:
                return self.getToken(GachaneitorParser.PUNTOYCOMA, i)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_ingrediente_lista

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIngrediente_lista" ):
                listener.enterIngrediente_lista(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIngrediente_lista" ):
                listener.exitIngrediente_lista(self)




    def ingrediente_lista(self):

        localctx = GachaneitorParser.Ingrediente_listaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_ingrediente_lista)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 75
                self.ingrediente()
                self.state = 76
                self.match(GachaneitorParser.PUNTOYCOMA)
                self.state = 80 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==GachaneitorParser.COMILLA):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IngredienteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMILLA(self, i:int=None):
            if i is None:
                return self.getTokens(GachaneitorParser.COMILLA)
            else:
                return self.getToken(GachaneitorParser.COMILLA, i)

        def IDENT_NOMBRE(self):
            return self.getToken(GachaneitorParser.IDENT_NOMBRE, 0)

        def DOSPUNTOS(self):
            return self.getToken(GachaneitorParser.DOSPUNTOS, 0)

        def cantidad(self):
            return self.getTypedRuleContext(GachaneitorParser.CantidadContext,0)


        def getRuleIndex(self):
            return GachaneitorParser.RULE_ingrediente

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIngrediente" ):
                listener.enterIngrediente(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIngrediente" ):
                listener.exitIngrediente(self)




    def ingrediente(self):

        localctx = GachaneitorParser.IngredienteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ingrediente)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82
            self.match(GachaneitorParser.COMILLA)
            self.state = 83
            self.match(GachaneitorParser.IDENT_NOMBRE)
            self.state = 84
            self.match(GachaneitorParser.COMILLA)
            self.state = 85
            self.match(GachaneitorParser.DOSPUNTOS)
            self.state = 86
            self.cantidad()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PasosContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PASOS(self):
            return self.getToken(GachaneitorParser.PASOS, 0)

        def LLAVE_ABIERTA(self):
            return self.getToken(GachaneitorParser.LLAVE_ABIERTA, 0)

        def LLAVE_CERRADA(self):
            return self.getToken(GachaneitorParser.LLAVE_CERRADA, 0)

        def paso(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GachaneitorParser.PasoContext)
            else:
                return self.getTypedRuleContext(GachaneitorParser.PasoContext,i)


        def getRuleIndex(self):
            return GachaneitorParser.RULE_pasos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPasos" ):
                listener.enterPasos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPasos" ):
                listener.exitPasos(self)




    def pasos(self):

        localctx = GachaneitorParser.PasosContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_pasos)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 88
            self.match(GachaneitorParser.PASOS)
            self.state = 89
            self.match(GachaneitorParser.LLAVE_ABIERTA)
            self.state = 91 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 90
                self.paso()
                self.state = 93 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==GachaneitorParser.GUION):
                    break

            self.state = 95
            self.match(GachaneitorParser.LLAVE_CERRADA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PasoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def paso_mov(self):
            return self.getTypedRuleContext(GachaneitorParser.Paso_movContext,0)


        def paso_coc(self):
            return self.getTypedRuleContext(GachaneitorParser.Paso_cocContext,0)


        def paso_per(self):
            return self.getTypedRuleContext(GachaneitorParser.Paso_perContext,0)


        def getRuleIndex(self):
            return GachaneitorParser.RULE_paso

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPaso" ):
                listener.enterPaso(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPaso" ):
                listener.exitPaso(self)




    def paso(self):

        localctx = GachaneitorParser.PasoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_paso)
        try:
            self.state = 100
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 97
                self.paso_mov()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 98
                self.paso_coc()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 99
                self.paso_per()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Paso_movContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GUION(self):
            return self.getToken(GachaneitorParser.GUION, 0)

        def VERBO_MOV(self):
            return self.getToken(GachaneitorParser.VERBO_MOV, 0)

        def ingrediente_lista(self):
            return self.getTypedRuleContext(GachaneitorParser.Ingrediente_listaContext,0)


        def tiempo(self):
            return self.getTypedRuleContext(GachaneitorParser.TiempoContext,0)


        def velocidad(self):
            return self.getTypedRuleContext(GachaneitorParser.VelocidadContext,0)


        def getRuleIndex(self):
            return GachaneitorParser.RULE_paso_mov

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPaso_mov" ):
                listener.enterPaso_mov(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPaso_mov" ):
                listener.exitPaso_mov(self)




    def paso_mov(self):

        localctx = GachaneitorParser.Paso_movContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_paso_mov)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self.match(GachaneitorParser.GUION)
            self.state = 103
            self.match(GachaneitorParser.VERBO_MOV)
            self.state = 104
            self.ingrediente_lista()
            self.state = 105
            self.tiempo()
            self.state = 106
            self.velocidad()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Paso_cocContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GUION(self):
            return self.getToken(GachaneitorParser.GUION, 0)

        def VERBO_COC(self):
            return self.getToken(GachaneitorParser.VERBO_COC, 0)

        def ingrediente_lista(self):
            return self.getTypedRuleContext(GachaneitorParser.Ingrediente_listaContext,0)


        def tiempo(self):
            return self.getTypedRuleContext(GachaneitorParser.TiempoContext,0)


        def temperatura(self):
            return self.getTypedRuleContext(GachaneitorParser.TemperaturaContext,0)


        def getRuleIndex(self):
            return GachaneitorParser.RULE_paso_coc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPaso_coc" ):
                listener.enterPaso_coc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPaso_coc" ):
                listener.exitPaso_coc(self)




    def paso_coc(self):

        localctx = GachaneitorParser.Paso_cocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_paso_coc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 108
            self.match(GachaneitorParser.GUION)
            self.state = 109
            self.match(GachaneitorParser.VERBO_COC)
            self.state = 110
            self.ingrediente_lista()
            self.state = 111
            self.tiempo()
            self.state = 112
            self.temperatura()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Paso_perContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GUION(self):
            return self.getToken(GachaneitorParser.GUION, 0)

        def VERBO_PER(self):
            return self.getToken(GachaneitorParser.VERBO_PER, 0)

        def ingrediente_lista(self):
            return self.getTypedRuleContext(GachaneitorParser.Ingrediente_listaContext,0)


        def getRuleIndex(self):
            return GachaneitorParser.RULE_paso_per

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPaso_per" ):
                listener.enterPaso_per(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPaso_per" ):
                listener.exitPaso_per(self)




    def paso_per(self):

        localctx = GachaneitorParser.Paso_perContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_paso_per)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self.match(GachaneitorParser.GUION)
            self.state = 115
            self.match(GachaneitorParser.VERBO_PER)
            self.state = 116
            self.ingrediente_lista()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CantidadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERO(self):
            return self.getToken(GachaneitorParser.NUMERO, 0)

        def UNIDAD_CANTIDAD(self):
            return self.getToken(GachaneitorParser.UNIDAD_CANTIDAD, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_cantidad

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCantidad" ):
                listener.enterCantidad(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCantidad" ):
                listener.exitCantidad(self)




    def cantidad(self):

        localctx = GachaneitorParser.CantidadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_cantidad)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 118
            self.match(GachaneitorParser.NUMERO)
            self.state = 119
            self.match(GachaneitorParser.UNIDAD_CANTIDAD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TiempoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERO(self):
            return self.getToken(GachaneitorParser.NUMERO, 0)

        def UNIDAD_TIEMPO(self):
            return self.getToken(GachaneitorParser.UNIDAD_TIEMPO, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_tiempo

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTiempo" ):
                listener.enterTiempo(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTiempo" ):
                listener.exitTiempo(self)




    def tiempo(self):

        localctx = GachaneitorParser.TiempoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_tiempo)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.match(GachaneitorParser.NUMERO)
            self.state = 122
            self.match(GachaneitorParser.UNIDAD_TIEMPO)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemperaturaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEMPERATURA(self):
            return self.getToken(GachaneitorParser.TEMPERATURA, 0)

        def NUMERO(self):
            return self.getToken(GachaneitorParser.NUMERO, 0)

        def UNIDAD_TEMP(self):
            return self.getToken(GachaneitorParser.UNIDAD_TEMP, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_temperatura

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemperatura" ):
                listener.enterTemperatura(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemperatura" ):
                listener.exitTemperatura(self)




    def temperatura(self):

        localctx = GachaneitorParser.TemperaturaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_temperatura)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 124
            self.match(GachaneitorParser.TEMPERATURA)
            self.state = 125
            self.match(GachaneitorParser.NUMERO)
            self.state = 126
            self.match(GachaneitorParser.UNIDAD_TEMP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VelocidadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VELOCIDAD(self):
            return self.getToken(GachaneitorParser.VELOCIDAD, 0)

        def DIGITO_VELOCIDAD(self):
            return self.getToken(GachaneitorParser.DIGITO_VELOCIDAD, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_velocidad

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocidad" ):
                listener.enterVelocidad(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocidad" ):
                listener.exitVelocidad(self)




    def velocidad(self):

        localctx = GachaneitorParser.VelocidadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_velocidad)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self.match(GachaneitorParser.VELOCIDAD)
            self.state = 129
            self.match(GachaneitorParser.DIGITO_VELOCIDAD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





