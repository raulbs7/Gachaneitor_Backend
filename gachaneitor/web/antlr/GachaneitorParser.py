# Generated from web/antlr/Gachaneitor.g4 by ANTLR 4.9
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3#")
        buf.write("\u0091\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\3\2\3\2")
        buf.write("\7\2\'\n\2\f\2\16\2*\13\2\3\3\5\3-\n\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\4\5\48\n\4\3\4\3\4\3\4\3\4\3\5\5\5")
        buf.write("?\n\5\3\5\3\5\3\6\5\6D\n\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6")
        buf.write("\3\7\5\7N\n\7\3\7\3\7\3\7\3\7\3\b\3\b\5\bV\n\b\6\bX\n")
        buf.write("\b\r\b\16\bY\3\t\3\t\3\t\3\t\5\t`\n\t\3\t\3\t\3\n\5\n")
        buf.write("e\n\n\3\n\3\n\6\ni\n\n\r\n\16\nj\3\n\3\n\3\13\3\13\3\13")
        buf.write("\5\13r\n\13\3\f\3\f\3\f\3\f\3\f\3\f\3\r\3\r\3\r\3\r\3")
        buf.write("\r\3\r\3\16\3\16\3\16\3\16\3\17\3\17\3\17\3\20\3\20\3")
        buf.write("\20\3\21\3\21\3\21\3\21\3\22\3\22\3\22\3\22\2\2\23\2\4")
        buf.write("\6\b\n\f\16\20\22\24\26\30\32\34\36 \"\2\2\2\u008c\2$")
        buf.write("\3\2\2\2\4,\3\2\2\2\6\67\3\2\2\2\b>\3\2\2\2\nC\3\2\2\2")
        buf.write("\fM\3\2\2\2\16W\3\2\2\2\20[\3\2\2\2\22d\3\2\2\2\24q\3")
        buf.write("\2\2\2\26s\3\2\2\2\30y\3\2\2\2\32\177\3\2\2\2\34\u0083")
        buf.write("\3\2\2\2\36\u0086\3\2\2\2 \u0089\3\2\2\2\"\u008d\3\2\2")
        buf.write("\2$(\5\4\3\2%\'\5\4\3\2&%\3\2\2\2\'*\3\2\2\2(&\3\2\2\2")
        buf.write("()\3\2\2\2)\3\3\2\2\2*(\3\2\2\2+-\7\3\2\2,+\3\2\2\2,-")
        buf.write("\3\2\2\2-.\3\2\2\2./\7\27\2\2/\60\5\6\4\2\60\61\5\b\5")
        buf.write("\2\61\62\5\n\6\2\62\63\5\f\7\2\63\64\5\22\n\2\64\65\7")
        buf.write("\30\2\2\65\5\3\2\2\2\668\7\4\2\2\67\66\3\2\2\2\678\3\2")
        buf.write("\2\289\3\2\2\29:\7\31\2\2:;\7\34\2\2;<\7\31\2\2<\7\3\2")
        buf.write("\2\2=?\7\5\2\2>=\3\2\2\2>?\3\2\2\2?@\3\2\2\2@A\7\37\2")
        buf.write("\2A\t\3\2\2\2BD\7\6\2\2CB\3\2\2\2CD\3\2\2\2DE\3\2\2\2")
        buf.write("EF\7\27\2\2FG\7\7\2\2GH\5\36\20\2HI\7\b\2\2IJ\5\36\20")
        buf.write("\2JK\7\30\2\2K\13\3\2\2\2LN\7\r\2\2ML\3\2\2\2MN\3\2\2")
        buf.write("\2NO\3\2\2\2OP\7\27\2\2PQ\5\16\b\2QR\7\30\2\2R\r\3\2\2")
        buf.write("\2SU\5\20\t\2TV\7\n\2\2UT\3\2\2\2UV\3\2\2\2VX\3\2\2\2")
        buf.write("WS\3\2\2\2XY\3\2\2\2YW\3\2\2\2YZ\3\2\2\2Z\17\3\2\2\2[")
        buf.write("\\\7\31\2\2\\]\7\34\2\2]_\7\31\2\2^`\7\t\2\2_^\3\2\2\2")
        buf.write("_`\3\2\2\2`a\3\2\2\2ab\5\34\17\2b\21\3\2\2\2ce\7\f\2\2")
        buf.write("dc\3\2\2\2de\3\2\2\2ef\3\2\2\2fh\7\27\2\2gi\5\24\13\2")
        buf.write("hg\3\2\2\2ij\3\2\2\2jh\3\2\2\2jk\3\2\2\2kl\3\2\2\2lm\7")
        buf.write("\30\2\2m\23\3\2\2\2nr\5\26\f\2or\5\30\r\2pr\5\32\16\2")
        buf.write("qn\3\2\2\2qo\3\2\2\2qp\3\2\2\2r\25\3\2\2\2st\7\13\2\2")
        buf.write("tu\7\23\2\2uv\5\16\b\2vw\5\36\20\2wx\5\"\22\2x\27\3\2")
        buf.write("\2\2yz\7\13\2\2z{\7\24\2\2{|\5\16\b\2|}\5\36\20\2}~\5")
        buf.write(" \21\2~\31\3\2\2\2\177\u0080\7\13\2\2\u0080\u0081\7\25")
        buf.write("\2\2\u0081\u0082\5\16\b\2\u0082\33\3\2\2\2\u0083\u0084")
        buf.write("\7\32\2\2\u0084\u0085\7\20\2\2\u0085\35\3\2\2\2\u0086")
        buf.write("\u0087\7\32\2\2\u0087\u0088\7\22\2\2\u0088\37\3\2\2\2")
        buf.write("\u0089\u008a\7\16\2\2\u008a\u008b\7\32\2\2\u008b\u008c")
        buf.write("\7\21\2\2\u008c!\3\2\2\2\u008d\u008e\7\17\2\2\u008e\u008f")
        buf.write("\7\33\2\2\u008f#\3\2\2\2\16(,\67>CMUY_djq")
        return buf.getvalue()


class GachaneitorParser ( Parser ):

    grammarFileName = "Gachaneitor.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'receta'", "'nombre'", "'descripcion'", 
                     "'tiempo'", "'total'", "'preparacion'", "':'", "';'", 
                     "'-'", "'pasos'", "'ingredientes'", "'temperatura'", 
                     "'velocidad'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'{'", "'}'", "'\"'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'['", "']'" ]

    symbolicNames = [ "<INVALID>", "RECETA", "NOMBRE", "DESCRIPCION", "TIEMPO", 
                      "TOTAL", "PREPARACION", "DOSPUNTOS", "PUNTOYCOMA", 
                      "GUION", "PASOS", "INGREDIENTES", "TEMPERATURA", "VELOCIDAD", 
                      "UNIDAD_CANTIDAD", "UNIDAD_TEMP", "UNIDAD_TIEMPO", 
                      "VERBO_MOV", "VERBO_COC", "VERBO_PER", "OTROS_CARACTERES", 
                      "LLAVE_ABIERTA", "LLAVE_CERRADA", "COMILLA", "NUMERO", 
                      "DIGITO_VELOCIDAD", "IDENT_NOMBRE", "CADENA", "TILDES", 
                      "CONTENIDO_DESCRIPCION", "CORCHETE_ABIERTO", "CORCHETE_CERRADO", 
                      "COMMENT", "WS" ]

    RULE_inicio = 0
    RULE_receta = 1
    RULE_nombre = 2
    RULE_descripcion = 3
    RULE_tiempo_receta = 4
    RULE_ingredientes = 5
    RULE_ingrediente_lista = 6
    RULE_ingrediente = 7
    RULE_pasos = 8
    RULE_paso = 9
    RULE_paso_mov = 10
    RULE_paso_coc = 11
    RULE_paso_per = 12
    RULE_cantidad = 13
    RULE_tiempo = 14
    RULE_temperatura = 15
    RULE_velocidad = 16

    ruleNames =  [ "inicio", "receta", "nombre", "descripcion", "tiempo_receta", 
                   "ingredientes", "ingrediente_lista", "ingrediente", "pasos", 
                   "paso", "paso_mov", "paso_coc", "paso_per", "cantidad", 
                   "tiempo", "temperatura", "velocidad" ]

    EOF = Token.EOF
    RECETA=1
    NOMBRE=2
    DESCRIPCION=3
    TIEMPO=4
    TOTAL=5
    PREPARACION=6
    DOSPUNTOS=7
    PUNTOYCOMA=8
    GUION=9
    PASOS=10
    INGREDIENTES=11
    TEMPERATURA=12
    VELOCIDAD=13
    UNIDAD_CANTIDAD=14
    UNIDAD_TEMP=15
    UNIDAD_TIEMPO=16
    VERBO_MOV=17
    VERBO_COC=18
    VERBO_PER=19
    OTROS_CARACTERES=20
    LLAVE_ABIERTA=21
    LLAVE_CERRADA=22
    COMILLA=23
    NUMERO=24
    DIGITO_VELOCIDAD=25
    IDENT_NOMBRE=26
    CADENA=27
    TILDES=28
    CONTENIDO_DESCRIPCION=29
    CORCHETE_ABIERTO=30
    CORCHETE_CERRADO=31
    COMMENT=32
    WS=33

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class InicioContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def receta(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GachaneitorParser.RecetaContext)
            else:
                return self.getTypedRuleContext(GachaneitorParser.RecetaContext,i)


        def getRuleIndex(self):
            return GachaneitorParser.RULE_inicio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInicio" ):
                listener.enterInicio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInicio" ):
                listener.exitInicio(self)




    def inicio(self):

        localctx = GachaneitorParser.InicioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_inicio)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 34
            self.receta()
            self.state = 38
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GachaneitorParser.RECETA or _la==GachaneitorParser.LLAVE_ABIERTA:
                self.state = 35
                self.receta()
                self.state = 40
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RecetaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LLAVE_ABIERTA(self):
            return self.getToken(GachaneitorParser.LLAVE_ABIERTA, 0)

        def nombre(self):
            return self.getTypedRuleContext(GachaneitorParser.NombreContext,0)


        def descripcion(self):
            return self.getTypedRuleContext(GachaneitorParser.DescripcionContext,0)


        def tiempo_receta(self):
            return self.getTypedRuleContext(GachaneitorParser.Tiempo_recetaContext,0)


        def ingredientes(self):
            return self.getTypedRuleContext(GachaneitorParser.IngredientesContext,0)


        def pasos(self):
            return self.getTypedRuleContext(GachaneitorParser.PasosContext,0)


        def LLAVE_CERRADA(self):
            return self.getToken(GachaneitorParser.LLAVE_CERRADA, 0)

        def RECETA(self):
            return self.getToken(GachaneitorParser.RECETA, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_receta

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReceta" ):
                listener.enterReceta(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReceta" ):
                listener.exitReceta(self)




    def receta(self):

        localctx = GachaneitorParser.RecetaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_receta)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 42
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GachaneitorParser.RECETA:
                self.state = 41
                self.match(GachaneitorParser.RECETA)


            self.state = 44
            self.match(GachaneitorParser.LLAVE_ABIERTA)
            self.state = 45
            self.nombre()
            self.state = 46
            self.descripcion()
            self.state = 47
            self.tiempo_receta()
            self.state = 48
            self.ingredientes()
            self.state = 49
            self.pasos()
            self.state = 50
            self.match(GachaneitorParser.LLAVE_CERRADA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NombreContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMILLA(self, i:int=None):
            if i is None:
                return self.getTokens(GachaneitorParser.COMILLA)
            else:
                return self.getToken(GachaneitorParser.COMILLA, i)

        def IDENT_NOMBRE(self):
            return self.getToken(GachaneitorParser.IDENT_NOMBRE, 0)

        def NOMBRE(self):
            return self.getToken(GachaneitorParser.NOMBRE, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_nombre

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNombre" ):
                listener.enterNombre(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNombre" ):
                listener.exitNombre(self)




    def nombre(self):

        localctx = GachaneitorParser.NombreContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_nombre)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 53
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GachaneitorParser.NOMBRE:
                self.state = 52
                self.match(GachaneitorParser.NOMBRE)


            self.state = 55
            self.match(GachaneitorParser.COMILLA)
            self.state = 56
            self.match(GachaneitorParser.IDENT_NOMBRE)
            self.state = 57
            self.match(GachaneitorParser.COMILLA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DescripcionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONTENIDO_DESCRIPCION(self):
            return self.getToken(GachaneitorParser.CONTENIDO_DESCRIPCION, 0)

        def DESCRIPCION(self):
            return self.getToken(GachaneitorParser.DESCRIPCION, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_descripcion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDescripcion" ):
                listener.enterDescripcion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDescripcion" ):
                listener.exitDescripcion(self)




    def descripcion(self):

        localctx = GachaneitorParser.DescripcionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_descripcion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 60
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GachaneitorParser.DESCRIPCION:
                self.state = 59
                self.match(GachaneitorParser.DESCRIPCION)


            self.state = 62
            self.match(GachaneitorParser.CONTENIDO_DESCRIPCION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tiempo_recetaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LLAVE_ABIERTA(self):
            return self.getToken(GachaneitorParser.LLAVE_ABIERTA, 0)

        def TOTAL(self):
            return self.getToken(GachaneitorParser.TOTAL, 0)

        def tiempo(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GachaneitorParser.TiempoContext)
            else:
                return self.getTypedRuleContext(GachaneitorParser.TiempoContext,i)


        def PREPARACION(self):
            return self.getToken(GachaneitorParser.PREPARACION, 0)

        def LLAVE_CERRADA(self):
            return self.getToken(GachaneitorParser.LLAVE_CERRADA, 0)

        def TIEMPO(self):
            return self.getToken(GachaneitorParser.TIEMPO, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_tiempo_receta

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTiempo_receta" ):
                listener.enterTiempo_receta(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTiempo_receta" ):
                listener.exitTiempo_receta(self)




    def tiempo_receta(self):

        localctx = GachaneitorParser.Tiempo_recetaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_tiempo_receta)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 65
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GachaneitorParser.TIEMPO:
                self.state = 64
                self.match(GachaneitorParser.TIEMPO)


            self.state = 67
            self.match(GachaneitorParser.LLAVE_ABIERTA)
            self.state = 68
            self.match(GachaneitorParser.TOTAL)
            self.state = 69
            self.tiempo()
            self.state = 70
            self.match(GachaneitorParser.PREPARACION)
            self.state = 71
            self.tiempo()
            self.state = 72
            self.match(GachaneitorParser.LLAVE_CERRADA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IngredientesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LLAVE_ABIERTA(self):
            return self.getToken(GachaneitorParser.LLAVE_ABIERTA, 0)

        def ingrediente_lista(self):
            return self.getTypedRuleContext(GachaneitorParser.Ingrediente_listaContext,0)


        def LLAVE_CERRADA(self):
            return self.getToken(GachaneitorParser.LLAVE_CERRADA, 0)

        def INGREDIENTES(self):
            return self.getToken(GachaneitorParser.INGREDIENTES, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_ingredientes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIngredientes" ):
                listener.enterIngredientes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIngredientes" ):
                listener.exitIngredientes(self)




    def ingredientes(self):

        localctx = GachaneitorParser.IngredientesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_ingredientes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 75
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GachaneitorParser.INGREDIENTES:
                self.state = 74
                self.match(GachaneitorParser.INGREDIENTES)


            self.state = 77
            self.match(GachaneitorParser.LLAVE_ABIERTA)
            self.state = 78
            self.ingrediente_lista()
            self.state = 79
            self.match(GachaneitorParser.LLAVE_CERRADA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ingrediente_listaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ingrediente(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GachaneitorParser.IngredienteContext)
            else:
                return self.getTypedRuleContext(GachaneitorParser.IngredienteContext,i)


        def PUNTOYCOMA(self, i:int=None):
            if i is None:
                return self.getTokens(GachaneitorParser.PUNTOYCOMA)
            else:
                return self.getToken(GachaneitorParser.PUNTOYCOMA, i)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_ingrediente_lista

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIngrediente_lista" ):
                listener.enterIngrediente_lista(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIngrediente_lista" ):
                listener.exitIngrediente_lista(self)




    def ingrediente_lista(self):

        localctx = GachaneitorParser.Ingrediente_listaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_ingrediente_lista)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 85 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 81
                self.ingrediente()
                self.state = 83
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GachaneitorParser.PUNTOYCOMA:
                    self.state = 82
                    self.match(GachaneitorParser.PUNTOYCOMA)


                self.state = 87 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==GachaneitorParser.COMILLA):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IngredienteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMILLA(self, i:int=None):
            if i is None:
                return self.getTokens(GachaneitorParser.COMILLA)
            else:
                return self.getToken(GachaneitorParser.COMILLA, i)

        def IDENT_NOMBRE(self):
            return self.getToken(GachaneitorParser.IDENT_NOMBRE, 0)

        def cantidad(self):
            return self.getTypedRuleContext(GachaneitorParser.CantidadContext,0)


        def DOSPUNTOS(self):
            return self.getToken(GachaneitorParser.DOSPUNTOS, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_ingrediente

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIngrediente" ):
                listener.enterIngrediente(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIngrediente" ):
                listener.exitIngrediente(self)




    def ingrediente(self):

        localctx = GachaneitorParser.IngredienteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ingrediente)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 89
            self.match(GachaneitorParser.COMILLA)
            self.state = 90
            self.match(GachaneitorParser.IDENT_NOMBRE)
            self.state = 91
            self.match(GachaneitorParser.COMILLA)
            self.state = 93
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GachaneitorParser.DOSPUNTOS:
                self.state = 92
                self.match(GachaneitorParser.DOSPUNTOS)


            self.state = 95
            self.cantidad()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PasosContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LLAVE_ABIERTA(self):
            return self.getToken(GachaneitorParser.LLAVE_ABIERTA, 0)

        def LLAVE_CERRADA(self):
            return self.getToken(GachaneitorParser.LLAVE_CERRADA, 0)

        def PASOS(self):
            return self.getToken(GachaneitorParser.PASOS, 0)

        def paso(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GachaneitorParser.PasoContext)
            else:
                return self.getTypedRuleContext(GachaneitorParser.PasoContext,i)


        def getRuleIndex(self):
            return GachaneitorParser.RULE_pasos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPasos" ):
                listener.enterPasos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPasos" ):
                listener.exitPasos(self)




    def pasos(self):

        localctx = GachaneitorParser.PasosContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_pasos)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GachaneitorParser.PASOS:
                self.state = 97
                self.match(GachaneitorParser.PASOS)


            self.state = 100
            self.match(GachaneitorParser.LLAVE_ABIERTA)
            self.state = 102 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 101
                self.paso()
                self.state = 104 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==GachaneitorParser.GUION):
                    break

            self.state = 106
            self.match(GachaneitorParser.LLAVE_CERRADA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PasoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def paso_mov(self):
            return self.getTypedRuleContext(GachaneitorParser.Paso_movContext,0)


        def paso_coc(self):
            return self.getTypedRuleContext(GachaneitorParser.Paso_cocContext,0)


        def paso_per(self):
            return self.getTypedRuleContext(GachaneitorParser.Paso_perContext,0)


        def getRuleIndex(self):
            return GachaneitorParser.RULE_paso

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPaso" ):
                listener.enterPaso(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPaso" ):
                listener.exitPaso(self)




    def paso(self):

        localctx = GachaneitorParser.PasoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_paso)
        try:
            self.state = 111
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 108
                self.paso_mov()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 109
                self.paso_coc()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 110
                self.paso_per()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Paso_movContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GUION(self):
            return self.getToken(GachaneitorParser.GUION, 0)

        def VERBO_MOV(self):
            return self.getToken(GachaneitorParser.VERBO_MOV, 0)

        def ingrediente_lista(self):
            return self.getTypedRuleContext(GachaneitorParser.Ingrediente_listaContext,0)


        def tiempo(self):
            return self.getTypedRuleContext(GachaneitorParser.TiempoContext,0)


        def velocidad(self):
            return self.getTypedRuleContext(GachaneitorParser.VelocidadContext,0)


        def getRuleIndex(self):
            return GachaneitorParser.RULE_paso_mov

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPaso_mov" ):
                listener.enterPaso_mov(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPaso_mov" ):
                listener.exitPaso_mov(self)




    def paso_mov(self):

        localctx = GachaneitorParser.Paso_movContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_paso_mov)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self.match(GachaneitorParser.GUION)
            self.state = 114
            self.match(GachaneitorParser.VERBO_MOV)
            self.state = 115
            self.ingrediente_lista()
            self.state = 116
            self.tiempo()
            self.state = 117
            self.velocidad()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Paso_cocContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GUION(self):
            return self.getToken(GachaneitorParser.GUION, 0)

        def VERBO_COC(self):
            return self.getToken(GachaneitorParser.VERBO_COC, 0)

        def ingrediente_lista(self):
            return self.getTypedRuleContext(GachaneitorParser.Ingrediente_listaContext,0)


        def tiempo(self):
            return self.getTypedRuleContext(GachaneitorParser.TiempoContext,0)


        def temperatura(self):
            return self.getTypedRuleContext(GachaneitorParser.TemperaturaContext,0)


        def getRuleIndex(self):
            return GachaneitorParser.RULE_paso_coc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPaso_coc" ):
                listener.enterPaso_coc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPaso_coc" ):
                listener.exitPaso_coc(self)




    def paso_coc(self):

        localctx = GachaneitorParser.Paso_cocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_paso_coc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self.match(GachaneitorParser.GUION)
            self.state = 120
            self.match(GachaneitorParser.VERBO_COC)
            self.state = 121
            self.ingrediente_lista()
            self.state = 122
            self.tiempo()
            self.state = 123
            self.temperatura()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Paso_perContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GUION(self):
            return self.getToken(GachaneitorParser.GUION, 0)

        def VERBO_PER(self):
            return self.getToken(GachaneitorParser.VERBO_PER, 0)

        def ingrediente_lista(self):
            return self.getTypedRuleContext(GachaneitorParser.Ingrediente_listaContext,0)


        def getRuleIndex(self):
            return GachaneitorParser.RULE_paso_per

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPaso_per" ):
                listener.enterPaso_per(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPaso_per" ):
                listener.exitPaso_per(self)




    def paso_per(self):

        localctx = GachaneitorParser.Paso_perContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_paso_per)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self.match(GachaneitorParser.GUION)
            self.state = 126
            self.match(GachaneitorParser.VERBO_PER)
            self.state = 127
            self.ingrediente_lista()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CantidadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERO(self):
            return self.getToken(GachaneitorParser.NUMERO, 0)

        def UNIDAD_CANTIDAD(self):
            return self.getToken(GachaneitorParser.UNIDAD_CANTIDAD, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_cantidad

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCantidad" ):
                listener.enterCantidad(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCantidad" ):
                listener.exitCantidad(self)




    def cantidad(self):

        localctx = GachaneitorParser.CantidadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_cantidad)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.match(GachaneitorParser.NUMERO)
            self.state = 130
            self.match(GachaneitorParser.UNIDAD_CANTIDAD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TiempoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERO(self):
            return self.getToken(GachaneitorParser.NUMERO, 0)

        def UNIDAD_TIEMPO(self):
            return self.getToken(GachaneitorParser.UNIDAD_TIEMPO, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_tiempo

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTiempo" ):
                listener.enterTiempo(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTiempo" ):
                listener.exitTiempo(self)




    def tiempo(self):

        localctx = GachaneitorParser.TiempoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_tiempo)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.match(GachaneitorParser.NUMERO)
            self.state = 133
            self.match(GachaneitorParser.UNIDAD_TIEMPO)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemperaturaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEMPERATURA(self):
            return self.getToken(GachaneitorParser.TEMPERATURA, 0)

        def NUMERO(self):
            return self.getToken(GachaneitorParser.NUMERO, 0)

        def UNIDAD_TEMP(self):
            return self.getToken(GachaneitorParser.UNIDAD_TEMP, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_temperatura

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemperatura" ):
                listener.enterTemperatura(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemperatura" ):
                listener.exitTemperatura(self)




    def temperatura(self):

        localctx = GachaneitorParser.TemperaturaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_temperatura)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            self.match(GachaneitorParser.TEMPERATURA)
            self.state = 136
            self.match(GachaneitorParser.NUMERO)
            self.state = 137
            self.match(GachaneitorParser.UNIDAD_TEMP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VelocidadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VELOCIDAD(self):
            return self.getToken(GachaneitorParser.VELOCIDAD, 0)

        def DIGITO_VELOCIDAD(self):
            return self.getToken(GachaneitorParser.DIGITO_VELOCIDAD, 0)

        def getRuleIndex(self):
            return GachaneitorParser.RULE_velocidad

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocidad" ):
                listener.enterVelocidad(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocidad" ):
                listener.exitVelocidad(self)




    def velocidad(self):

        localctx = GachaneitorParser.VelocidadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_velocidad)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 139
            self.match(GachaneitorParser.VELOCIDAD)
            self.state = 140
            self.match(GachaneitorParser.DIGITO_VELOCIDAD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





